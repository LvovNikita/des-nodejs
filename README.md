# DES

Реализация блочного алгоритма шифрования DES. В академических целях. В разработке

---

## Таблицы:

* IP.js — таблица начальной перестановки IP
* E.js — таблица функции расширения E
* IP-1.js — таблица конечной перестановки IP<sup>-1</sup>
* S-Boxes.js — S—блоки
* P.js — P-блоки
* PC-1.js — перестановка битов ключа PC-1
* PC-2.js — перестановка битов ключа PC-2

---

## Конструктор:

```
constructor(key) {    
    this.key = DES.allocateKey(key)
    this.roundKeys = DES.generateRoundKeys(this.key)
    this.status = ['ALLOCATE KEY']
    this.data = null
    this.blocks = []
}
```

Создание экземпляра класса:

```
const des = new DES(key)
```

Ключ может быть 56-битной строкой или буфером.

При создании экземпляра класса аллоцируются ключ и 16 раундовых ключей статическими методами:

* DES.allocateKey(key)
* DES.generateRoundKeys(this.key)

Экзмепляр класса имеет следующие публичные методы и свойства:

```
des.encrypt(plaintext)  // шифрование
des.decrypt(ciphertext) // расшифрование

des.data                // данные в виде буфера или...
des.dataAsString        // в виде строки
```

Открытый текст и зашифрованный текст могут быть строкой или буфером.

---

## Входные данные примеров:

```
const key = 'SECRETK'
const plaintext = 'hello world'
```

---

## Статические методы:

### DES.allocateKey(key)

Ключ может быть 56-битной строкой или буфером. В противном случае он будет зациклен или обрезан до 56 бит.

Ключ в виде буфера: 
```
<Buffer 53 45 43 52 45 54 4b>
```

Из функции возвращается ключ в двоичном представлении, дополненный битами чётности. Таким образом 56-битный ключ расширяется до 64 бит.

```
[
    0, 1, 0, 1, 0, 0, 1, = 1,
    1, 0, 1, 0, 0, 0, 1, = 1,
    0, 1, 0, 1, 0, 0, 0, = 0,
    0, 1, 1, 0, 1, 0, 1, = 0, 
    0, 0, 1, 0, 0, 1, 0, = 0, 
    0, 0, 1, 0, 1, 0, 1, = 1,
    0, 1, 0, 1, 0, 0, 0, = 0, 
    1, 0, 0, 1, 0, 1, 1, = 0
]
```
### DES.generateRoundKeys(this.key)

Схема генерации раундовых ключей:

* Permuted Choice 1: 64 bit -> 56 bit
* Взятие левой и правой частей ключа
* Инициализация раундовых ключей
* Permuted Choice 2

#### PC-1

Из 64-битного ключа отбросить биты чётности (7, 15, 23, 31, 39, 47, 55, 63) и пермешать их, согласно таблице PC-1 в файле *./tables/PC-1.js*. В результате ключ сжимается до 56 бит.

![PC-1](https://upload.wikimedia.org/wikipedia/commons/thumb/3/38/DES-pc1.svg/400px-DES-pc1.svg.png)

Источник изображения: Wikipedia

Пример ключа (*5) после PC-1. В первой строке биты 56, 48, 40, 32, 24, 16, 8, 0 ключа до перестановки:

```
[
    1, 0, 0, 0, 0, 0, 1, 0,
    0, 1, 0, 0, 1, 1, 0, 1,
    0, 0, 1, 1, 1, 0, 1, 0,
    1, 1, 0, 0, 1, 0, 1, 0,
    1, 0, 1, 1, 1, 0, 0, 1,
    0, 0, 0, 0, 0, 0, 1, 0,
    1, 0, 0, 0, 0, 1, 0, 1
]
```

#### Взятие левой и правой частей ключа

56-битный ключ разделяется на две части по 28 бита:

```
C0 = [
    1, 0, 0, 0, 0, 0, 1, 0,
    0, 1, 0, 0, 1, 1, 0, 1,
    0, 0, 1, 1, 1, 0, 1, 0,
    1, 1, 0, 0
]

D0 = [
                1, 0, 1, 0, 
    1, 0, 1, 1, 1, 0, 0, 1,
    0, 0, 0, 0, 0, 0, 1, 0,
    1, 0, 0, 0, 0, 1, 0, 1
]
```

#### Инициализация раундовых ключей

Инициализируетcя 16 раундовых ключей, в первом раунде получаемых из C<sub>0</sub> и D<sub>0</sub>, а в последующих из C<sub>i-1</sub> и D<sub>i-1</sub> (где i — номер раунда) путём циклического сдвига на 1 (1, 2, 9, 16 раунды) или 2 бита влево.

Результат — двумерный массив из 16 раундовых ключей длиной 56 битов.

Пример ключей на первые три раунда, полученные из C0 и D0 циклическим сдвигом:

```
[
    [
        0, 0, 0, 0, 0, 1, 0, 0,
        1, 0, 0, 1, 1, 0, 1, 0, 
        0, 1, 1, 1, 0, 1, 0, 1,
        1, 0, 0, 1, 
                    0, 1, 0, 1, 
        0, 1, 1, 1, 0, 0, 1, 0, 
        0, 0, 0, 0, 0, 1, 0, 1,
        0, 0, 0, 0, 1, 0, 1, 1
    ],
    [
        0, 0, 0, 0, 1, 0, 0, 1,
        0, 0, 1, 1, 0, 1, 0, 0,
        1, 1, 1, 0, 1, 0, 1, 1,
        0, 0, 1, 0, 
                    1, 0, 1, 0,
        1, 1, 1, 0, 0, 1, 0, 0,
        0, 0, 0, 0, 1, 0, 1, 0,
        0, 0, 0, 1, 0, 1, 1, 0
    ],
    [
        0, 0, 1, 0, 0, 1, 0, 0,
        1, 1, 0, 1, 0, 0, 1, 1,
        1, 0, 1, 0, 1, 1, 0, 0,
        1, 0, 0, 0, 
                    1, 0, 1, 1,
        1, 0, 0, 1, 0, 0, 0, 0,
        0, 0, 1, 0, 1, 0, 0, 0,
        0, 1, 0, 1, 1, 0, 1, 0
    ],
    ...
]
```

#### Permuted Choice 2

---

## Приватные методы:

###









---

## Схема шифрования

Для простоты отладки методы объединены в цепочку:

```
encrypt() = this
    .#byteBlockToBinary()
    .#ip()
    .#getBlockHalves()
    .#generateRoundKeys()
    .#f()
    .#fp()
    .#binaryBlockToBytes()
```

* .byteBlockToBinary() — блок данных, представляющий из себя 8-байтовый Buffer представить в виде двоичного массива;
* .ip() — начальная перестановка бит блока IP;
* .getBlockHalves() — разделить блок на две части L и R по 32 бита каждая;
* .generateRoundKeys() — сгенерировать раундовые подключи;
* .f() — раундовая функция F
* .fp() — конечная перестановка бит блока IP-1 (FP)
* .binaryBlockToBytes() — ...

---



## Методы класса DES:

### private DES.byteBlockToBinary()

Приватный метод. Преобразует 64-битный блок открытого текста из Buffer'а в двоичный массив нулей и единиц. 

Пример преобразования блока (*1):

```
block: [
    // "h" = 104 = 0b01101000
    '0', '1', '1', '0', '1', '0', '0', '0',
    // "e" = 101 = 0b01100101
    '0', '1', '1', '0', '0', '1', '0', '1',
    // ... 
    '0', '1', '1', '0', '1', '1', '0', '0', 
    '0', '1', '1', '0', '1', '1', '0', '0',
    '0', '1', '1', '0', '1', '1', '1', '1',
    '0', '0', '1', '0', '0', '0', '0', '0', 
    '0', '1', '1', '1', '0', '1', '1', '1', 
    '0', '1', '1', '0', '1', '1', '1', '1'
] // (*2)
```

Устанавливает в качестве статуса состояния: **CONVERT_BYTE_BLOCK_TO_BINARY**.

### private DES.ip()

Приватный метод. Реализует начальную перестановку бит в блоке IP, согласно таблице в файле *./tables/IP.js*. 57-ой бит становится нулевым, 49-ый — первым и т. д.

![IP](https://upload.wikimedia.org/wikipedia/commons/thumb/8/8f/DES-ip-1.svg/400px-DES-ip-1.svg.png) 

Источник изображения: Wikipedia

Пример перестановки бит блока (*2):

```
block: [
    // 57, 49, 41, 33, 25, 17,  9, 1, — номера бит из (*2) 
    '1', '1', '0', '1', '1', '1', '1', '1',
    // ...
    '0', '1', '0', '0', '0', '0', '0', '0',
    '1', '1', '0', '1', '1', '1', '1', '0',
    '1', '1', '0', '1', '0', '0', '1', '0',
    '0', '0', '0', '0', '0', '0', '0', '0',
    '1', '1', '1', '1', '1', '1', '1', '1',
    '1', '0', '0', '1', '1', '1', '0', '1',
    '1', '1', '0', '1', '0', '0', '0', '0'
] // (*3)
```

Устанавливает в качестве статуса состояния: **INITIAL_PERMUTATION**.

### private DES.byteKeyToBinary()

Приватный метод. Преобразует 64-битный ключ из Buffer'а в двоичный массив нулей и единиц. 

Пример преобразования ключа (*4):

```
key: [
    // 75 = 0b01001011
    '0', '1', '0', '0', '1', '0', '1', '1', 
    // 69 = 0b01000101
    '0', '1', '0', '0', '0', '1', '0', '1', 
    // ...
    '0', '1', '0', '1', '1', '0', '0', '1',
    '0', '1', '0', '0', '1', '0', '1', '1',
    '0', '1', '0', '0', '0', '1', '0', '1',
    '0', '1', '0', '1', '1', '0', '0', '1',
    '0', '1', '0', '0', '1', '0', '1', '1',
    '0', '1', '0', '0', '0', '1', '0', '1'
] // (*5)
```

Устанавливает в качестве статуса состояния: **KEYS: CONVERT_BYTE_KEY_TO_BINARY**.

### private DES.pc2()

Приватный метод. Сжимает 56-битные раундовые ключи до 48 бит (игнорируются биты: 8, 17, 21, 24, 34, 37, 42, 53) и перемешивает биты, согласно таблице PC-2 в файле *./tables/PC-2.js*.

![PC-2](https://upload.wikimedia.org/wikipedia/commons/thumb/5/52/DES-pc2.svg/400px-DES-pc2.svg.png) 

Источник изображения: Wikipedia

Пример ключа на первый раунд после применения к нему (*8) PC-2:

```
roundKeys[0]: [
    // 13, 16, 10, 23,  0,  4,  2, 27 — номера бит из (*8)
    '1', '0', '1', '0', '0', '0', '0', '0',
    // ..
    '1', '0', '0', '1', '0', '0', '1', '0',
    '1', '1', '0', '0', '0', '0', '1', '0',
    '0', '0', '0', '0', '0', '0', '0', '0',
    '1', '1', '0', '1', '0', '1', '1', '0',
    '0', '1', '1', '1', '0', '1', '1', '1'
] // (*9)
```

### private DES.f()

Приватный метод. Раундовая функция. Выполняется 16 раз.

Для простоты отладки методы соединены в цепочку. На каждой итерации выполняется:

```
f() = this
    .#getNewL()
    .#e()
    .#RXorRoundKey(round)
    .#splitR(round)
    .#s(round)
    .#p()
    .#getNewR()
```

#### Описание шагов, входящих в раундовую функцию:

* .#getNewL() — левая часть L<sub>i+1</sub> становится правой R<sub>i</sub> (*3 — после первого раунда)
* .#e() — правая часть R, длиной 32 бита, расширяется до 48 бит, согласно таблице расширения E в файле *./tables/E.js* (часть бит дублируется). R (*3) в результате расширения в первом раунде:

```
R: [
    // 31,  0,  1,  2,  3,  4, 3,  4 — номера бит из (*3)
    '0', '0', '0', '0', '0', '0', '0', '0',
    '0', '0', '0', '1', '0', '1', '1', '1',
    '1', '1', '1', '1', '1', '1', '1', '1',
    '1', '1', '0', '0', '1', '1', '1', '1',
    '1', '0', '1', '1', '1', '1', '1', '0',
    '1', '0', '1', '0', '0', '0', '0', '0'
] // (*10)
```
![E](https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/DES-ee.svg/400px-DES-ee.svg.png)

Источник изображения: Wikipedia

* .#RXorRoundKey(round) — 48-битная правая часть (*10), побитово складывается по модулю два с соответсвующим 48-битным раундовым ключом (*9 в первом раунде). PATCH: исправлена ошибка версии 0.1.0, когда сложение фактически не проиходило

Пример R (*10) после сложения с ключом первого раунда (*9): 

```
R: [
    // 1 ^ 0 = 1, 0 ^ 0 = 0, ...
    '1', '0', '1', '0', '0', '0', '0', '0',   
    '1', '0', '0', '0', '0', '1', '0', '1',
    '0', '0', '1', '1', '1', '1', '0', '1', 
    '1', '1', '0', '0', '1', '1', '1', '1', 
    '0', '1', '1', '0', '1', '0', '0', '0',
    '1', '1', '0', '1', '0', '1', '1', '1'
] // (*11)
```

* .#splitR(round) — разделить правую часть (*11) на 8 частей по 6 бит

Результат:

```
R_chunks: [
    [ '1', '0', '1', '0', '0', '0' ],
    [ '0', '0', '1', '0', '0', '0' ],
    [ '0', '1', '0', '1', '0', '0' ],
    [ '1', '1', '1', '1', '0', '1' ],
    [ '1', '1', '0', '0', '1', '1' ],
    [ '1', '1', '0', '1', '1', '0' ],
    [ '1', '0', '0', '0', '1', '1' ],
    [ '0', '1', '0', '1', '1', '1' ]
] // (*12)
```

* .#s(round) — S-блоки (блоки замены). Каждая из восьми 6-битных частей R (*12) поступает на вход одного из восьми блоков замены, определённых в файле *./tables/S-Boxes.js*. Первый и последний биты части блока R определяют номер строки (0-3), а оставшиеся четыре бита номер столбца (0-15) в блоке замены. На выходе из S-блока 6-битная последовательность сжимается до 4 бит. Иллюстрация:

![S](https://www.researchgate.net/profile/Miroslaw-Szaban/publication/220440933/figure/fig7/AS:668741075484682@1536451705920/Function-S-box-S1-in-the-DES-algorithm-represented-as-a-table-and-its-work-on-the.ppm)

Источник изображения: ResearchGate.net

Например, R_chunks (*12) после замены выглядит следующим образом (48 бит превращаются в 32):

```
R_chunks:[
    // номер строки в S-блоке = 10, столбца = 0100 (см. *12)
    // во второй строке, четвёртом столбце S-блока — 14 (1101)
    [ '1', '1', '0', '1' ],
    // строка 00, столбец 01000 (см. *12)
    [ '0', '1', '1', '0' ],
    //
    [ '1', '1', '0', '0' ],
    [ '0', '0', '1', '0' ],
    [ '1', '1', '1', '1' ],
    [ '1', '0', '1', '0' ],
    [ '1', '0', '1', '1' ],
    [ '1', '0', '1', '1' ]
] // (*13)
```

Получаем новое 32-битное значение путём преобразования двумерного массива в одномерный (*13):

```
R: [
    '1', '1', '0', '1', '0', '1', '1', '0', 
    '1', '1', '0', '0', '0', '0', '1', '0',
    '1', '1', '1', '1', '1', '0', '1', '0',
    '1', '0', '1', '1', '1', '0', '1', '1'
], // (*14)
```

* .#p() — P-блок (блок перестановки). Правая часть R (*14) поступает на вход блока перестановки, определённого в файле *./tables/P.js*.

Пример правой части (*14) после применения перестановки P:

```
R: [
    // 15, 6, 19, 20, ... биты из R (*14)
    '0', '1', '1', '1', '1', '0', '1', '1', 
    '1', '1', '1', '0', '0', '1', '1', '1', 
    '1', '0', '0', '0', '1', '1', '0', '1',
    '1', '0', '0', '1', '0', '0', '1', '1'
], // (*16)
```

* .#getNewR() — наконец, получаем новую правую часть R на следующий раунд, путём сложения по модулю 2 бит левой части L (*15) и правой части R, полученной на выходе раундовой функции (*16)

Результат сложения по модулю 2 соответствующих бит L (*15 II) и R (*16):

```
R: [
    // 1 ^ 0 = 1, 1 ^ 1 = 0 , 0 ^ 1 = 1, 1 ^ 1 = 0, ... 
    '1', '0', '1', '0', '0', '1', '0', '0', 
    '1', '0', '1', '0', '0', '1', '1', '1',
    '0', '1', '0', '1', '0', '0', '1', '1',
    '0', '1', '0', '0', '0', '0', '0', '1'
], (*17)
```

* После чего склеиваются полученные левая и правая части L (*15 II) и R (*17), где L<sub>i</sub> является R<sub>i - 1</sub>, а R<sub>i</sub> получена в результате применения раундовой функции к R<sub>i-1</sub> и последующего побитового сложения по модулю 2 с L<sub>i-1</sub>. В коде:

```
// join L and R
this.ciphertext = [...this.L, ...this.R] 
```

Результат:

```
ciphertext: [
    // L (*15):
    '0', '0', '0', '0', '0', '0', '0', '0',
    '1', '1', '1', '1', '1', '1', '1', '1',
    '1', '0', '0', '1', '1', '1', '0', '1',
    '1', '1', '0', '1', '0', '0', '0', '0',
    // R (*17):
    '1', '0', '1', '0', '0', '1', '0', '0',
    '1', '0', '1', '0', '0', '1', '1', '1',
    '0', '1', '0', '1', '0', '0', '1', '1',
    '0', '1', '0', '0', '0', '0', '0', '1'
]
```

---

# allocateKey 

key = 'ABC' -> 'ABCABCA' (7 byte)
-> add parity bits -> 8 byte

parity bits:
```
[
  0, 1, 0, 0, 0, 0, 0, = 1
  1 ,0, 1, 0, 0, 0, 0, = 0
  1, 0, 0, 1, 0, 0, 0, = 0
  0, 1, 1, 0, 1, 0, 0, = 1
  0, 0, 0, 1, 0, 1, 0, = 0
  0, 0, 0, 1, 0, 0, 1, = 0 
  0, 0, 0, 0, 1, 1, 0, = 0
  1, 0, 0, 0, 0, 0, 1  = 0
]
```